/*
 * 
 */
package com.jpmorgan.trader.mockdata;

import java.math.BigDecimal;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Date;
import java.util.HashMap;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.stream.Collectors;

import com.jpmorgan.trader.domain.CurrencyToWeekEndMapping;
import com.jpmorgan.trader.domain.Instruction;
import com.jpmorgan.trader.domain.Order;
import com.jpmorgan.trader.domain.Trade;
import com.jpmorgan.trader.domain.TradeDetails;
import com.jpmorgan.trader.enums.Action;
import com.jpmorgan.trader.enums.OrderStatus;
import com.jpmorgan.trader.value.AmountReport;
import com.jpmorgan.trader.value.EntityRankKey;
import com.jpmorgan.trader.value.EntityRankReport;

/**
 * This is mock data. In real world it would be replaced by JPA/Hibernate calls,
 * named queries etc.
 * 
 * Here, it also have instruction set as input. Here, it acts as cache, memory
 * database etc. We are doing sum, group by here in java but in real world it
 * would be in SQL.
 * 
 * @author Administrative
 *
 */
public class MockDataBase {
	
	/** The trade list. */
	private static List<Trade> tradeList = new ArrayList<>();
	
	/** The trade details list. */
	private static List<TradeDetails> tradeDetailsList = new ArrayList<>();
	
	/** The count. */
	private static int count = 0;

	/**
	 * Gets the currency to week end map.
	 *
	 * @return the currency to week end map
	 */
	public static List<CurrencyToWeekEndMapping> getCurrencyToWeekEndMap() {
		List<CurrencyToWeekEndMapping> currencyToWeekEndMappingList = new ArrayList<CurrencyToWeekEndMapping>();
		currencyToWeekEndMappingList.add(new CurrencyToWeekEndMapping("SGP", "SAT,SUN"));
		currencyToWeekEndMappingList.add(new CurrencyToWeekEndMapping("AED", "FRI,SAT"));
		currencyToWeekEndMappingList.add(new CurrencyToWeekEndMapping("SAR", "FRI,SAT"));

		return currencyToWeekEndMappingList;
	}

	/**
	 * Adds the instruction.
	 *
	 * @param instruction the instruction
	 * @return the instruction
	 */
	public static Instruction addInstruction(Instruction instruction) {
		// after saving to database, new instruction id would be generated by hibernate
		instruction.setInstructionId(getUniqueId());
		return instruction;
	}

	/**
	 * Save order.
	 *
	 * @param order the order
	 * @return the order
	 */
	public static Order saveOrder(Order order) {
		// after saving to database, new order id would be generated by hibernate
		order.setOrderId(getUniqueId());
		return order;
	}

	/**
	 * Gets the order status.
	 *
	 * @return the order status
	 */
	public static OrderStatus getOrderStatus() {
		count++;
		if (count % 2 == 0) {
			// if the entity is available at the price ordered then it can executed with
			// success
			return OrderStatus.SUCCESS;
		} else if (count % 3 == 0) {
			// If the entity is NOT available at the price it is ordered
			// then order will remain in pending state
			return OrderStatus.PENDING;
		} else if (count % 5 == 0) {
			// if the money in account is less than the order amount then it can be rejected
			return OrderStatus.REJECTED;
		} else {
			return OrderStatus.SUCCESS;
		}
	}

	/**
	 * Save trade.
	 *
	 * @param trade the trade
	 * @return the trade
	 */
	public static Trade saveTrade(Trade trade) {
		// after saving to database, new trade id would be generated by hibernate
		trade.setTradeId(getUniqueId());
		tradeList.add(trade);
		return trade;
	}

	/**
	 * Gets the unique id.
	 *
	 * @return the unique id
	 */
	private static long getUniqueId() {
		// In real world, hibernate will return new generated ID here
		return System.currentTimeMillis();
	}

	/**
	 * Gets the trade list.
	 *
	 * @return the trade list
	 */
	public static List<Trade> getTradeList() {
		return tradeList;
	}

	/**
	 * Retrieve outgoing amount every day.
	 *
	 * @return the list
	 */
	public static List<AmountReport> retrieveOutgoingAmountEveryDay() {
		List<AmountReport> tradeAmountValueList = new ArrayList<>();
		// here group by action and date and sum the amount for action "B"
		// Here java 8 feature of Group By, sum etc, can be used
		// not doing it due to time constraint
		Map<Date, BigDecimal> outgoingAmountEveryDayMap = new HashMap<>();
		for (TradeDetails tradeDetails : tradeDetailsList) {
			if (tradeDetails.getAction() == Action.BUY) {
				BigDecimal amount = outgoingAmountEveryDayMap.get(tradeDetails.getSettlementDate());
				if (amount == null) {
					outgoingAmountEveryDayMap.put(tradeDetails.getSettlementDate(),
							tradeDetails.getAmountOfTradeInUSD());
				} else {
					outgoingAmountEveryDayMap.put(tradeDetails.getSettlementDate(),
							amount.add(tradeDetails.getAmountOfTradeInUSD()));
				}
			}
		}
		outgoingAmountEveryDayMap.forEach((key, value) -> tradeAmountValueList.add(new AmountReport(value, key)));
		return tradeAmountValueList;
	}

	/**
	 * Retrieve incoming amount every day.
	 *
	 * @return the list
	 */
	public static List<AmountReport> retrieveIncomingAmountEveryDay() {
		List<AmountReport> tradeAmountValueList = new ArrayList<>();
		// here group by action and date and sum the amount for action "S"
		// Here java 8 feature of Group By, sum etc, can be used
		// not doing it due to time constraint
		Map<Date, BigDecimal> incomingAmountEveryDayMap = new HashMap<>();
		for (TradeDetails tradeDetails : tradeDetailsList) {
			if (tradeDetails.getAction() == Action.SELL) {
				BigDecimal amount = incomingAmountEveryDayMap.get(tradeDetails.getSettlementDate());
				if (amount == null) {
					incomingAmountEveryDayMap.put(tradeDetails.getSettlementDate(),
							tradeDetails.getAmountOfTradeInUSD());
				} else {
					incomingAmountEveryDayMap.put(tradeDetails.getSettlementDate(),
							amount.add(tradeDetails.getAmountOfTradeInUSD()));
				}
			}
		}
		incomingAmountEveryDayMap.forEach((key, value) -> tradeAmountValueList.add(new AmountReport(value, key)));
		return tradeAmountValueList;
	}

	/**
	 * Retrieve incoming entity rank every day.
	 *
	 * @return the list
	 */
	public static List<EntityRankReport> retrieveIncomingEntityRankEveryDay() {
		List<EntityRankReport> entityRankList = new ArrayList<>();
		// here group by action,date and entity and rank the entity for action "B"
		// Here java 8 feature of Group By, sum, max, order by etc, can be used
		// not doing it due to time constraint
		Map<EntityRankKey, BigDecimal> incomingEntityRankEveryDayMap = new HashMap<>();
		for (TradeDetails tradeDetails : tradeDetailsList) {
			if (tradeDetails.getAction() == Action.SELL) {
				EntityRankKey entityRankKey = new EntityRankKey(tradeDetails.getEntityName(),
						tradeDetails.getSettlementDate());
				BigDecimal amount = incomingEntityRankEveryDayMap.get(entityRankKey);
				if (amount == null) {
					incomingEntityRankEveryDayMap.put(entityRankKey, tradeDetails.getAmountOfTradeInUSD());
				} else {
					incomingEntityRankEveryDayMap.put(entityRankKey, amount.add(tradeDetails.getAmountOfTradeInUSD()));
				}
			}
		}

		incomingEntityRankEveryDayMap = incomingEntityRankEveryDayMap.entrySet().stream()
				.sorted(Collections.reverseOrder(Map.Entry.comparingByValue()))
				.collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue, (e1, e2) -> e2, LinkedHashMap::new));
		final AtomicInteger rank = new AtomicInteger(0);
		incomingEntityRankEveryDayMap.forEach((key, value) -> entityRankList
				.add(new EntityRankReport(key.getEntityName(), key.getDate(), rank.incrementAndGet())));
		return entityRankList;
	}

	/**
	 * Retrieve outgoing entity rank every day.
	 *
	 * @return the list
	 */
	public static List<EntityRankReport> retrieveOutgoingEntityRankEveryDay() {
		List<EntityRankReport> entityRankList = new ArrayList<>();
		// here group by action,date and entity and rank the entity for action "S"
		// Here java 8 feature of Group By, sum, max, order by etc, can be used
		// not doing it due to time constraint
		Map<EntityRankKey, BigDecimal> outgoingEntityRankEveryDayMap = new HashMap<>();
		for (TradeDetails tradeDetails : tradeDetailsList) {
			if (tradeDetails.getAction() == Action.BUY) {
				EntityRankKey entityRankKey = new EntityRankKey(tradeDetails.getEntityName(),
						tradeDetails.getSettlementDate());
				BigDecimal amount = outgoingEntityRankEveryDayMap.get(entityRankKey);
				if (amount == null) {
					outgoingEntityRankEveryDayMap.put(entityRankKey, tradeDetails.getAmountOfTradeInUSD());
				} else {
					outgoingEntityRankEveryDayMap.put(entityRankKey, amount.add(tradeDetails.getAmountOfTradeInUSD()));
				}
			}
		}

		outgoingEntityRankEveryDayMap = outgoingEntityRankEveryDayMap.entrySet().stream()
				.sorted(Collections.reverseOrder(Map.Entry.comparingByValue()))
				.collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue, (e1, e2) -> e2, LinkedHashMap::new));
		final AtomicInteger rank = new AtomicInteger(0);
		outgoingEntityRankEveryDayMap.forEach((key, value) -> entityRankList
				.add(new EntityRankReport(key.getEntityName(), key.getDate(), rank.incrementAndGet())));
		return entityRankList;
	}

	/**
	 * Gets the trade details list.
	 *
	 * @return the trade details list
	 */
	public static List<TradeDetails> getTradeDetailsList() {
		return tradeDetailsList;
	}

	/**
	 * Save trade details.
	 *
	 * @param tradeDetailsListP the trade details list P
	 */
	public static void saveTradeDetails(List<TradeDetails> tradeDetailsListP) {
		tradeDetailsList = tradeDetailsListP;
	}

}